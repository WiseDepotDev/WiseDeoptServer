# 慧仓智控后端代码审查规范

本规范用于指导慧仓智控（WiseDeoptServer）后端代码在评审时的统一标准，重点覆盖模块化架构约束、编码规范、测试与安全等方面，帮助团队在竞赛与展示场景下保持代码质量与可维护性。

## 一、模块化架构要求

- 模块划分
  - 父工程：`wise-deopt-parent`（聚合 POM，不直接产出可运行包）
  - 子模块：
    - `wise-deopt-common`：通用工具、基础 DTO、统一响应结构、通用异常等；
    - `wise-deopt-domain`：领域模型、实体、领域服务接口、领域枚举与值对象；
    - `wise-deopt-infrastructure`：数据库访问、第三方接口适配、消息中间件等基础设施实现；
    - `wise-deopt-application`：应用服务、用例编排、事务边界与业务流程；
    - `wise-deopt-api`：Spring Boot 启动入口与 REST API 控制器层。

- 依赖方向（必须在评审时重点检查）
  - 允许依赖：
    - `common` 可被所有模块依赖；
    - `domain` 依赖 `common`；
    - `infrastructure` 依赖 `domain` 和 `common`；
    - `application` 依赖 `domain`、`infrastructure` 和 `common`；
    - `api` 依赖 `application` 和 `common`。
  - 禁止依赖：
    - `domain` 不得依赖 `api`、`infrastructure`；
    - `common` 不得依赖任何业务模块；
    - `api` 不得直接依赖 `infrastructure` 或直接操作持久化层。

- 包结构建议（评审时可对照）
  - `com.wisedeopt.common.*`
  - `com.wisedeopt.domain.*`
  - `com.wisedeopt.infrastructure.*`
  - `com.wisedeopt.application.*`
  - `com.wisedeopt.api.*`

评审时需确认新代码是否放入合理模块、是否破坏既有依赖方向。

## 二、通用编码规范

- 命名规范
  - 包名：全部小写，使用有语义的单词，如 `auth`, `inventory`, `task` 等；
  - 类名：使用大驼峰命名，名词或名词短语，如 `UserService`, `InventoryTask`；
  - 方法名：使用小驼峰命名，需体现动作，如 `createUser`, `calculateRoute`；
  - 变量名：语义清晰，避免 `a`, `b`, `flag` 等无含义命名；
  - 常量：全部大写，下划线分隔，如 `DEFAULT_PAGE_SIZE`。

- 代码风格
  - 尽量保持单一职责，一个类、方法只做一件明确的事；
  - 方法长度宜控制在 50 行以内，超过需考虑拆分；
  - 避免魔法值，使用常量或枚举承载固定含义的数值与字符串；
  - 禁止在业务代码中写死环境配置、密钥、账号等敏感信息。

- 空值与可空处理
  - 入参校验必须明确：非空、范围、枚举合法性；
  - 避免随处返回 `null`，必要时使用 `Optional` 或清晰的返回约定；
  - 集合返回宜使用空集合代替 `null`。

- 注释与文档
  - 类、方法、字段需有清晰的中文注释，描述其作用、参数、返回值、异常等；
  - 接口文档需使用 Swagger 或 OpenAPI 规范，描述入参、出参、异常码等。
  - 清晰标注出最终修改人，避免多人修改导致代码冲突。

## 三、REST API 设计与控制器层

- 接口设计
  - 路径需语义化，推荐使用名词复数，如 `/users`, `/tasks`, `/inventories`；
  - 使用 HTTP 方法表达动作：`GET` 查询，`POST` 创建，`PUT` 全量更新，`PATCH` 局部更新，`DELETE` 删除；
  - 对外暴露的接口需有清晰的请求/响应模型，避免直接暴露实体。

- 入参与出参
  - 入参对象需使用专门的请求 DTO，不直接使用领域实体；
  - 出参优先使用统一返回结构（如 `code` + `message` + `data`）；
  - 注意与《后端异常码对照表》保持一致，异常码在接口返回中需可追踪。

- 控制器职责
  - 控制器只做参数接收、基础校验、调用应用服务、返回结果；
  - 复杂业务逻辑必须下沉到 `application` 或 `domain` 层；
  - 控制器内不得直接操作仓储、数据源或第三方 SDK。

## 四、领域与应用层规范

- 领域层（`domain`）
  - 聚焦业务概念：实体、值对象、领域服务、领域事件等；
  - 保持与技术细节解耦，不引入 ORM、HTTP 客户端等基础设施类；
  - 业务规则尽量内聚在领域模型中，实现高内聚、低耦合。

- 应用层（`application`）
  - 负责用例编排和事务边界，例如“创建任务”“执行盘点”“生成报表”等；
  - 尽量通过接口依赖基础设施实现，降低对具体实现的耦合；
  - 应用服务方法需具有明确的输入输出，避免在无返回的 `void` 方法中做过多隐式行为。

- 基础设施层（`infrastructure`）
  - 聚焦技术实现：JPA/MyBatis 仓储实现、消息队列、缓存、外部 API 适配器等；
  - 严格遵守接口分离原则，仅对外暴露领域或应用层定义的接口；
  - 禁止在基础设施层写业务决策逻辑。

## 五、异常处理与错误码

- 异常分类
  - 参数校验类异常：入参不合法、缺少字段、范围错误等；
  - 业务规则类异常：不满足领域规则，如库存不足、权限不足；
  - 系统类异常：数据库/缓存/消息中间件不可用，网络错误等。

- 错误码规范
  - 必须与 `wise-depot-plan/后端异常码对照表.csv` 中的约定保持一致；
  - 新增异常码需先在表中设计，再在代码中引用；
  - 接口返回中须包含错误码与人类可读的错误信息，便于竞赛现场排障与演示。

- 全局异常处理
  - 应在 `api` 模块中统一配置全局异常处理器，将异常转换为统一响应结构；
  - 禁止在各层大量 `try-catch` 后悄悄吞异常，必须记录日志或向上抛出；
  - 日志中需包含 `requestId` 或等价追踪信息，方便与前端、网关日志关联。

## 六、数据访问与事务

- 仓储与数据访问
  - 仓储接口应定义在 `domain` 或 `application` 中，实现放在 `infrastructure`；
  - 禁止将 ORM 实体直接暴露到 API 层，对外使用 DTO；
  - 查询与命令逻辑尽量分离，复杂查询考虑读写分离或专用查询对象。

- 事务管理
  - 使用 Spring 声明式事务（如 `@Transactional`）统一管理事务边界；
  - 确保跨多个仓储操作的用例在一个明确的应用服务中完成；
  - 严格控制事务粒度，避免在事务内执行耗时 IO（如远程调用、文件操作）。

## 七、日志与监控

- 日志级别
  - `INFO`：关键业务流程节点，如登录成功、任务创建、任务完成；
  - `WARN`：可恢复异常或潜在问题，如重试成功、阈值接近等；
  - `ERROR`：无法恢复的异常或导致业务失败的情况；
  - 禁止在正常流程中大量使用 `DEBUG` 或 `TRACE` 级日志。

- 日志内容
  - 必须避免记录明文密码、密钥、token 等敏感信息；
  - 日志中应包含关键业务标识（用户 ID、任务 ID、资产 ID 等）；
  - 重要接口应在入口和出口记录关键字段和执行耗时。

## 八、测试与质量保障

- 单元测试
  - 核心业务逻辑必须配备单元测试，优先覆盖领域与应用层；
  - 测试命名需表达清晰意图，如 `shouldCreateTaskWhenInputValid`；
  - 避免依赖真实外部服务，使用 Mock 或测试替身。

- 集成测试（视时间与场景而定）
  - 关键业务流程可编写集成测试验证 API 行为；
  - 测试环境与生产（或竞赛演示环境）配置保持尽量一致。

- 质量门禁建议
  - PR 不通过构建与测试不得合并；
  - 严格禁止直接向主干分支推送未评审代码；
  - 竞赛前需要至少一次完整回归测试。

## 九、安全与配置

- 配置管理
  - 环境相关配置（数据库、MQ、缓存、外部服务地址等）须通过配置文件或环境变量注入；
  - 禁止将密钥、证书、密码写入代码库；
  - `application.yml` 中的敏感信息需通过占位符或加密方式处理。

- 安全检查
  - 所有对外接口需结合网关、鉴权策略进行访问控制；
  - 对敏感操作（出库、权限变更、密钥管理等）需有额外校验或审计日志；
  - 使用框架默认防护机制，避免 SQL 注入、XSS 等常见漏洞。

## 十、代码评审流程建议

- 提交前自检
  - 确认模块划分合理，依赖方向未被破坏；
  - 通过本地构建与基础测试；
  - 消除明显的格式与警告问题。

- 评审重点清单
  - 是否遵守模块化架构和依赖约束；
  - 业务逻辑是否清晰、可读、可维护；
  - 是否覆盖必要的单元测试；
  - 是否正确使用错误码与异常处理；
  - 是否符合安全与配置管理要求；
  - 是否对竞赛/展示场景的关键路径有足够的健壮性。

本规范可根据后续实现进展按需补充与细化，评审时以本文件为基础，结合具体模块说明进行扩展。

## 十一、Commit 提交与分支规范（Conventional Commits）

- 提交频率与粒度
  - 每次提交应围绕一个相对独立、可描述清晰的改动；
  - 避免「大杂烩提交」，将重构、功能开发、修复 Bug 拆分为多次提交；
  - 提交前确保代码可编译通过，尽量保持主干分支随时可运行。

- 提交信息格式（推荐遵循 Conventional Commits）
  - 基本格式：`<type>(scope): <subject>`
  - `type` 建议取值：
    - `feat`：新增功能（feature）；
    - `fix`：修复 Bug；
    - `refactor`：重构，不改变对外行为的内部结构调整；
    - `perf`：性能优化；
    - `docs`：仅文档变更；
    - `test`：仅测试相关变更；
    - `chore`：构建流程、脚本、依赖升级等杂项；
    - `style`：代码风格调整，不影响逻辑（格式化、空格等）。
  - `scope`：可选，标明影响范围，如 `inventory`, `auth`, `task-api`；
  - `subject`：一句话概述变更，使用动词短语，首字母小写，结尾不加句号。

  示例：
  - `feat(inventory): 支持批量导入货位信息`
  - `fix(task-api): 修复任务分页参数校验错误`
  - `refactor(domain): 抽取盘点任务领域服务`

- 提交内容要求
  - 提交前完成自测，至少运行关键单元测试或手工验证主要用例；
  - 避免将临时代码、调试日志、无用注释提交到仓库；
  - 如引入破坏性变更（接口签名变更、字段删除等），需在提交信息中明确标注 `BREAKING CHANGE` 并在说明中详细描述影响。

- 分支命名建议
  - 功能分支：`feature/<模块>-<简要说明>`，如 `feature/inventory-batch-import`；
  - 修复分支：`fix/<模块>-<问题简述>`，如 `fix/task-page-param`；
  - 临时试验分支：`experiment/<说明>`，不直接合入主干。

- 合并与评审
  - 所有进入主干的改动必须通过合并请求（Pull Request）并完成至少一次代码评审；
  - 合并前需确保分支已与主干同步并解决冲突，不得在主干上直接解决冲突；
  - 评审通过后优先使用「Squash and merge」或「Rebase and merge」保持提交历史清晰（视团队习惯而定）。
